# 全体の構成・要素

- 静的動的ディスパッチ
  - C++の継承とトレイトオブジェクトを図入りで説明

- 型、所有・借用、可変性、生存期間

# 言語体系の中で対比

- ネイティブ言語
  - C/C++ (without GC)
  - Rust (without GC)
  - Go (with GC)
  - Swift/Objective-C (with GC)
  - Pascal
  - D
  - Haskel
  - OCaml
- VM(JIT)系
  - JVM
    - Java, Clojure, Scalar
  - CLR(Mono)
    - C#, F#
  - BEAM
    - Erlang
- スクリプト言語
  - Javascript
  - Ruby
  - Python
  - Perl
  - Lua

# History

- 2006: Graydon Hoare が個人プロジェクトを開始
- 2011: rustc がセルフコンパイル可能に（それ以前はOCamlで書かれていた）
- 2015: ver.1.0 最初の Stable 版
- Now: 6週間毎に Stable 版をローリングリリース


# Rustの位置づけ

- No GC
- システムプログラミング言語

# システムプログラミング言語とは

- 軽量、オーバーヘッドが少ない。
- OS
- カーネルプログラミング(デバイスドライバなど）
- ARM Cortex-M, AVRなどマイコン、組み込み系

これらのプログラミングが可能。
それを達成するためには、

- ネイティブな機械語を生成する
- 低水準へのアクセス
- リソースの透明性、自己管理
  - No GC

一言で言えば「C++を殺すための言語」

# 言語的特徴、印象

- C言語系手続き型言語の皮を被った別パラダイムの言語
  - Haskel, OCamlの影響が強い？

- Haskel, OCamlは仕事ではちょっと･･･。 -> Rustならワンチャン

- コンパイル時にできるだけ問題を解消
- 型が厳密、型推論が強力、寿命管理が厳密
- Genericsが強力、多用、C++のような一部の変態向けではない
- 省略省略(構文糖）多め、'?'記法など
- 文(Statement)よりも式(Expression)指向
- パターンマッチ便利
- Cargo 便利
  - Batteries included

- 処理系が一つなのは何気にありがたい(vs C++)
- 実質 nightly build が標準
- 若い言語なので情報が錯綜しがち

彽レイヤを扱いつつ、高レイヤでパズル

- Vs Go言語
  - リソースの不透明さがない、OSに対して透過的(Stack/Heap, Goroutine)
  - 衛生的なマクロ
  - Generics

# オブジェクト指向？

Rustはオブジェクト指向言語ではないが･･･

- カプセル化
  - モジュール(Crate)単位での外部露出制御

- ポリモーフィズム
  - GenericsとTraits

# コンパイルが通れば･･･

- メモリ、ファイルハンドラなどのリークがない
- マルチスレッド環境にてレースコンディションやデッドロックが起こらない

･･･ことが保証される。

# 所有権 (Ownership)

- 所有件と寿命はコンパイラが保証する
- GC (Reference Count)をコンパイル時におこなうようなもの
- ･･･、それ以上にこの言語を性格付けしている中核概念

# 安全性

- 暗黙のキャストは許さない
- 整数のオーバーフローは補足されPanicを出す（デバッグビルド時）

- プログラミング的な不整合はPanicを起こす
  - Panicはクラッシュではない。
  - このヤバイことが起こる前にスタックを巻き返す
  - 他のスレッドは動作する

# エラーハンドリング

- C++, Go
  - if文でエラーを補足
  - try-catch（例外）はほとんど使われない

- Rust
  - Result と Panic
  - Result によるパターンマッチング
  - `?`文法（構文糖）による省略


# スレッド安全性

- Rustはスレッド安全性が言語機能（制約）にはじめから組み込まれている
  - コンパイルさえ通ればレースコンディションは解決している

- C++ は C++11 まで言語仕様にスレッドなる概念は存在しなかった
- 比較的新しく平行処理機能を備えるGoでさえレースコンディションはやっかいな問題

# 参照 

- Rustに参照はあるがNULL、ダングリングポインタは存在しない。
  - 多くの言語がこれらの問題に苦しめられている
  - Optionで用いる

# 多相性（ポリモーフィズム）

- ジェネリック関数
  - C++のテンプレートと似てる。静的コンパイル時に翻訳される
  - 強力な型推論があるので多様される
- トレイトオブジェクト
  - 実データとvtableを指すファットポインタ。動的。
  - メカニズムはGoのinterfaceと似てる

# Trait

- Goのinterfaceに似ている
- Fat Pointerによる実現
  - 小さな型(u32など)にも適応可能
  - 多重継承などを回避

C++のvptrとTraitObject(Fat pointer)の比較図を用意する

# マクロ

- 文字列置換ではなくトークン単位のパターンマッチング(Syntax Rule)
- マクロはsuffixに'!'がつく ex: println!("It's {}!", obj)


# まとめ、個人的な評価

久しぶりに出た非GC、ネイティブ開発システム言語

同じであってもパラダイムが大分違うのでRustにC++は殺せない？

厳密性が求められるため軽量なプロトタイピングが必要となるゲーム開発にはやや不向き？

# メモ

- Copy, Clone Traitがつけば楽



struct S { id: u32, }
fn main() {
	let obj = S{ id: 42 };
}
